# day12

상속
==> 이미 만들어져 있는 클래스를 그대로 물려받아
	추가/수정 하여 사용하는 클래스를 통해 프로그램 만드는 기법.
	
	참조형 변수
		타입을 결정하는 것은
		instance의 변수 쪽 클래스의 맴버 유무에 결정된다.
	
	Finally
	sub class의 맴버는 super class의 맴버보다 많을 것.
	
	Overriding
		0.
		1. 함수의 원형이 일치해야 한다.
		   ㄴ 반환값타입+함수이름+매개변수리스트
		2. 접근 지정자는 같거나 넓은 방향으로.
		3. 예외처리는 같거나 좁은 방향으로
		
	상속관계에 있는 경우
		상위 클래스의 변수에서 함수를 호출하게 되면
		최종적으로, sub class에서 overriding한 함수가 호출됨.
		
--------------------------------------------------------------------------
다형성
==> 하나의 변수를 이용하여 여러 형태의 클래스를 사용하게 하는 것.

	Casting(주소의 형변환)
	==> 원칙적으로 instance는 다른 형태로의 형변환이 불가능.
		Heap type에 따라 주소가 결정됨.
		Heap type이 다르면 주소를 기억할 수 없다.
		ex.
			int[] num=new float[10]	==> NG!!!
			
			Test t=new Sample();	==> 상속관계면 가능 (Test와 Sample 클래스)
			
		※ 예외 : 상속관계(is a 관계)에 있는 클래스들
		
			자동 형변환
			==> sub class의 주소가 super class 변수에 기억되는 것
				은 자동으로 해줌!
				
			강제 형변환
			==> super class의 주소가 sub class의 변수에 기억되는 것
				은 원칙적으로 불가능! (없는 맴버가 있기 때문)
				
				강제로 형변환 하면.. 되기는 함. 근데 오류날 확률 큼
				ex.
					class Mother {}
					
					class Daugther {}
					
					Mother m=new Daugther();	==> 자동형변환
					Daugther d=new Mother();	==> NG!!!
					
					Mother m1=new Mother();
					Daugther d=(Daugther) m;
					
	그래서 그게 뭐냐고
		super class의 변수를 통해 sub class를 이용 가능하며
		super class의 변수를 이용하면
		여러 sub class의 instance들을 다룰 수 있다.
		
		최종 목적 : sub class의 instance를 super class의 reference로 다룸
		
		+ class의 instance type?
			그 인스턴스에 해당 맴버의 존재 유무로 따진다.
			
	<다형성 언제 쓰는디?>
		1. 어떤 함수가 super class를 매개 변수로 갖고 있다면
			sub class instance를 입력해도 OK.
			
			따라서 만약 어떤 함수가 Object type으로 매개변수가 정해져 있다면
			별달리 Object class의 instance를 만들 필요가 없다.
			
		2. 어떤 함수가 super class를 반환값으로 갖고 있다면
			반드시 원하는 sub class 형태로 변환 해야 한다. ~※[Test03]
			
			+ 어떤 반환값이나 넘겨 받은 데이터 타입이 Object인 경우
			  그 데이터를 연산할 때, 반드시
			  원래 갖는 타입으로 강제 형변환 해줘야 함.
			  
--------------------------------------------------------------------------
abstract class : 상속과 함께 java의 꽃
==> 추상 함수를 '0개 이상' 갖고 있는 클래스.
	추상 함수가 한개라도 있으면 반드시 추상클래스로 만들어야 한다.
	
	abstract method
	==> 함수의 블럭{}이 없는 함수.
		기능이 없는 함수다!!
		
		형식
			접근지정자 abstract	반환값 함수이름(매개변수 리스트);
			
	추상클랴수 만들긔~
	
		접근지정자 abstract class 클래스이름{
			변수선언;
			
			일반함수(){}
			일반함수(){}
			
			[ 추상함수(); ]	==> 선택~
		}
		
	왜있는디? : 다형성 구현
	
	추상클래스의 활용
	==> 추상클래스는 new가 불가능!
		대부분 이 클래스의 sub class에서 객체가 만들어진다.
		
		1. 다른 클래스에 상속해준 후
		   추상함수의 기능을 만들어준다. ({}블럭 안에 기능구현!)
		   
		   sub class를 new 시켜 추상클래스의 변수에 담아 사용!
			==> 실무에서 이렇게 쓰이는 경우는 10% 미만..
			
		2. 많이 쓰이는 방법~은!
			추상 클래스 안에 static 이며 반환값이 자기 자신인 함수를 찾아
			그 함수를 호출해 instance를 얻어서 사용하면 된다.
			ex.
				Calendar 클래스 사용법
				
				Calendar cal=Calendar.getInstance();
				==> 함수가 Calendar 인스턴스를 반환해 준다.
				
		+ 추상클래스가 아님에도, 생성자 함수가 없는것 처럼 보이는 클래스가 있다.
		  ==> 생성자의 접근지정자를 private으로 감춰놓은 것이다!
		  
		  이 경우, 마찬가지로 new 시켜 사용 할 수 없고
		  추상클래스 활용 2번과 같이 사용하여야 한다.
		  
		  만약 자기 자신에게 그런 함수가 없다면
		  관련된 클래스에 그런 함수가 있으므로 그걸 찾아 호출하면 된다링.
		  
--------------------------------------------------------------------------
Interface
==> 클래스의 한 종류이기는 하지만 특수한 클래스이다.

	1. Object class 가 아니다.
		Interface class는 어떠한 super class도 갖지 않는다.
	
	2. Interface내에 일반함수가 존재할 수 없다.
		abstract method만 존재할 수 있다.
		
		+ Interface 내에서는 접근지정자와 속성을 지정하지 않아도
			public abstract가 자동적으로 붙여진다.
			
	3. Interface는 반드시 sub class를 가질 필요가 있다.
		다중 상속이 가능하다.
		
	4. 변수를 가질 수 있는데, 이 변수는 자동적으로
		public static final	이 붙게 된다.
		
얘 왜 필요한데?
==> 가끔 JVM에 의해 자동 호출되는 함수와 충돌되는 함수가 있을 수 있다.
	이 충돌을 막기 위함이다.
	
활용
	1. Interface는 클래스 내에서 new시킬 수 없다.
		타 abstract class와 같이,
		기능이 없는 abstract method들 또한 그렇다.
		
		일반클래스에 상속하여 활용한다.
			class 클래스이름 [extends subclassname] implements 인터페이스이름, 인터페이스이름 .... {}
			
		+ 일반 sub class의 생성을 "상속"이라고 표현하고
		  Interface 클래스의 상속은 "구현"이라 표현한다.
		  
	2. abstract class의 특성을지닌다.
		상속받은 클래스에서는
		Interface 클래스의 기능의 내용을 채워줄 필요가 있다.
		
	3. 구현된 클래스를 new 시켜 사용한다.	==> 사용 빈도 90%
		나머지 10% => 속성이 static이며, 해당 Interface 타입인 함수를 찾아 사용.
		
		※ Interface를 구현할때 주의점!
		  구현되는 모든 클래스의 모든 함수를 오버라이딩 해줘야 함.
		  
		  + 반드시 클래스 상속 구문이 인터페이스 구현보다 전술되어야 한다.
		  
--------------------------------------------------------------------------
~토막상식~

 1.	Interface끼리 상속받을 수도 있따!
		
		interface 인터페이스이름 extends 상속할인터페이스이름 {}
		
 2.	Interface 안에 일반함수가 오는 경우가 없진 않다!
	이 경우, 함수의 속성을 default라고 명시해 주어야만 한다.
		
		default 반환값타입 함수이름() {}
--------------------------------------------------------------------------
Inner class
==> 클래스 안에 다시 클래스를 만들 수 잇따.

종류
	1. Top Level Inner class
	==>형식만 Inner class, 독립적으로 활동한다.
			static class 클래스이름 {}
			
		즉, 내부에 만들지만 static에 올린다는 것이여.
		
		+ 내부 클래스의 이름은 일반 클래스와 다르다.
			"바깥 클래스 이름.내부 클래스"

	2. 전역 Inner class***많이 씀! (일반적으로 통용되는 내부 클래스는 이걸 뜻함)
	==>일반 클래스를 내부 클래스로 만든 것!
			class 클래스이름 {}
			
		특징
		 1.	바깥 클래스의 모든 맴버를 자기 것처럼 사용할 수 있다.
		 2.	바깥 클래스를 new 시킨 후 사용해야 생성할 수 있다.
		 		바깥클래스주소.new 내부클래스이름();
		 3.	바깥 클래스는 안쪽 클래스의 맴버를 쓸 수 없다.
		 	쓸려면 new 시켜야 함.
		 	
		 언제쓰는디?
		 	주로 바깥 클래스와 연관된 기능을 가진 클래스를 만들고 싶을 때.
		 	
		 	+ 클래스의 내용이 짧은 경우, 파일을 따로 만드는게 번거로울 수 있다.
		 	  이 때 내부 클래스를 활용하면 편리함.
	
	3. 지역 Inner class
	==> 내부 클래스를 만드는 위치가 바깥 클래스의 함수 안에서 만들어 지는 것.
		ex.
			class Test{
				int a;
				class Inner {}	==> 전역 내부 클래스
				
				void abc(){
					int no=0;
					class Inner02{}	==> 지역 내부 클래스
				}
			}
			
		특징
		 1.	전역 내부 클래스와 유사하게, 바깥 클래스의 맴버를 사용할 수 있음.
		 2.	이 클래스는 소속된 함수 블럭 바깥에서만 new 시켜 사용할 수 없다.
	
	3. 무명 Inner class**중요함!!
	==> 이름이 없는 내부 클래스
		
		프로그램을 제작하다 보면, 오버라이드를 하거나
		인터페이스/추상클래스를 사용해야 할 때가 있다.
		
		이 때, 원칙적으론 일반 sub class를 만들고
		그 클래스를 객체로 만든 후 사용해야 한다.
		
		
		하지만 간단한 오버라이드의 경우,
		하나의 Method때문에 이 작업을 한다는 건 불편하다.
		
	그래서 이게 뭔데 씹덕아
		위에 기술한 사유로 만들어졌다.
		클래스를 new 시키는 순간,
		필요한 기능을 override해서 사용하는 방법.
		
	형식
		new 인터페이스이름(){
			추상함수 오버라이딩
		}
		
		new 추상클래스이름() {
			추상함수 오버라이딩
		}