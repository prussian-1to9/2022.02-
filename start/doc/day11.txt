# day11

this
==> 교과서적인 의미로는
	현재 실행중인 객체의 주소를 기억하는, 약속된 변수이다.
	
	이것은 JVM이 클래스를 처리하기 위해서 JVM이 사용하는 변수
	즉, 개발자는 거의 이 변수를 사용하지 않는다.
	
	규칙
		1.  모든 맴버는 사용할 때 반드시 앞에 주소가 있어야 함.
			
			따라서 new 시킨 후, 그 주소를 기억해 놓았다가
			그 주소를 이용해 사용하는 것이다.
			
		2. 	만약 주소가 없으면 JVM이 자동으로 this를 붙여준다.
		3.	맴버 함수를 호출할 때는 무조건 주소값을 함수에게 알려주도록 약속되어 있고
			함수는 this 변수를 준비한 후
			함수를 호출할 때 알려준 주소를 기억하게 된다.
			
		+ 개발자가 this를 사용해야 하는 경우
			가끔은 지역변수와 맴버변수 이름이 동일하게 만들어지는 경우가 있다.
			이러면, 그 함수는 지역변수를 우선적으로 사용한다.
			
			※ 굳이 이 변수가 맴버 변수임을 반드시 밝혀야 되는 경우가 생기면
			  this 라고 써주면 됩니더.
			  
---------------------------------------------------------------------
static
	static 영역에 올라가는 함수나 변수에 붙여주는 속성.
	
	+ 클래스, 함수, 변수를 만들 때 속성을 지정할 수 있다.
		접근지정자 [속성] class 클래스이름 {}
		접근지정자 [속성] 반환값타입 함수이름(매개변수리스트) {}
		접근지정자 [속성] 데이터타입 변수이름;
		
	static 영역의 특징
		1.  프로그램이 실행되기 위해 JVM이 로딩되는 순간 저절로 생기는 영역이다.
			즉, 사용자가  특별히 만들어달라고 하지 않아도 자동적으로 생긴다.
				
		2.  한 번 생긴 변수나 함수는 두번 생기지 않는다.
			
	<static 변수>
		static 영역에 만들어지는 변수.
			접근지정자 static [속성] 데이터타입 변수이름;
		ex.
			public static final int dream;
				
		특징
			1. 여러 Object(객체)가 '공동'으로 사용하는 변수.
			
			-> 객체를 100개를 만들었을 때, Heap영역에 메모리는 할당 되겠지만
			   static변수는 static영역에 한번만 올라가기 때문.
			       따라서 한 오브젝트에서 데이터를 바꾸면
			       다른 오브젝트들도 바뀐 그 데이터를 사용한다.
			   -> static 변수는 오브젝트의 의미가 없다!!
			      + 오브젝트가 없어도 사용할 수 있다.
			      
			2. new 시키지 않아도 사용할 수 있는 변수!
			-> 이미 static 영역에 올려져 있기 때문.
			
			+ static 맴버엔 this를 붙일 수 없다.
			  static 맴버는 Heap에 올라가는 데이터가 아니다.
			     그리고 객체 각각에 올라가는게 아닌, static에 한번만 올라가는 데이터다.
			   
	<static 함수>
		static 변수와 마찬가지로 static 영역에 올려지는 함수.
		-> 객체를 만들지 않아도 사용할 수 있는 함수!
		         ※ this를 사용할 수 없다.
	
	결론
		static 함수 안에서는 메모리에 올려진 것들만 사용할 수 있다.
		일반 함수 안에선 static 맴버, 그리고 일반 맴버 둘 다 사용 가능.
		
---------------------------------------------------------------------
맴버변수의 초기화
	맴버 변수는 Heap영역에 생기므로 자동 초기화가 된다.
	하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
	
	1. 명시적 초기화
		==> 변수를 선언하며 값을 대입하는것.
			다른 초기화보다 먼저 실행된다.
			ex.
				int no=323;
				
	2. 초기화 블럭을 이용한 초기화
		==> 인스턴스 변수에 한해서만 가능한 방법.
			두 번째로 초기화된다.
			형식
			{
				변수=데이터;
			}
			
	3. static 블럭을 이용한 초기화
		static{	//static블럭
			데이터입력
		}
		
	4. 생성자를 이용한 초기화
		==> 가장 마지막에 실행되는 방법
		ex.
			public Test(){
				no=100;	// 생성자를 이용한 초기화
			}
---------------------------------------------------------------------
객체지향 언어의 특징
	1. 상속
	2. 다형성
	3. 은닉화 / 캡슐화
---------------------------------------------------------------------	
상속
	이미 만들어진 클래스의 기능을 그대로 부여받아 (변수와 함수의 기능을 그대로 복사해)
	새로운 클래스를 만드는 방법.
	
	소프트웨어 개발 속도를 빠르게 하기 위한 방법 중 하나이다.
	
	즉, 상속은 객체 지향에서 매우 중요한 역할을 하는 것으로
	객체 지향 언어는 부품(클래스)단위로 프로그램을 만든 후
	그 부품을 조립해, 원하는 결과를 얻어내는 것인디!
	
	어딘가에서 부품(클래스)를 구했는디 그 기능에 수정이 필요할 수 있다.
	이 때 필요한것이 상속이여.
	
	상속은 자신이 필요한 기능과 가상 유사한 클래스를 가져와서
	일단 그 기능을 다 복사한 후,
		1. 없는 기능은 더하고
		2. 수정할 기능은 수정하고		하는것이여.
		
	형식)
		접근지정자 [속성] class 클래스이름 extends 복사해올클래스 {}
		
	※ java는 오직 단일 상속만 가능하다. (여러 클래스에서 상속을 받을 수 없다.)
	
	용어
		Super class	: 상위 클래스. 상속을 '해 준' 클래스	(부모)
		Sub class	: 하위 클래스. 상속 '받은' 클래스		(자식)
		
		is a		: 상속 관계에 있는 클래스를 부르는 용어.
		ex.
			class Mother {}
			class Daughter extends Mother {}
			==> Daughter is a Mother 가 성립된다.
			
		has a		: 어떤 클래스 안에 다른 클래스를 갖고 있는 상태.
		ex.
			class Mother {}
			class Daughter extends Mother {
				Mother m=new Mother();
			}
			==> Daughter has a Mother 가 성립된다.
			
---------------------------------------------------------------------	
함수의 오버리이딩 (Overriding : 함수의 재정의)
==> 상속관계에 있는 하위클래스에서
	상위 클래스가 가지고 있는 함수의 기능을 수정하는 행위
	
	방법!
		0. 상위 클래스가 존재해야 한다.
		1. 상위 클래스가 가진 함수의 Prototype과 동일한 원형으로 만들어야 함.
		
			Method Prototype
				반환값+함수이름+매개변수 리스트
				
		2. 접근 지정자는 같거나 넓은 방향으로 기술한다.
		3. 예외처리는 같거나 좁은 방향으로.. (이후 다시 설명)
		
	오버라이딩을 하면
		내부적으로 super 함수가 숨겨지고 재정의한 함수가 사용된다.
		
			class Mother {
				public void abc() {
					System.out.println("시작...!");
				}
			}
			
			==>
			class Mother extends Mother() {
				public void abc() {
					System.out.println("만세!");
				}
			}
			
			void xyz() {}
			
			상위 클래스의 abc함수 호출하는 방법
				super.abc();
				
				abc();
				
	super
	==> this가 현재 실행중인 객체 자기자신을 기억하는 
		super 역시 예약된 변수 중 하나이다.
		자신의 상위 클래스의 객체의 주소를 기억하는 변수이다.
		
		사용 목적 : 반드시 소속을 밝혀야 하는 경우에 사용한다.
---------------------------------------------------------------------
Object class
==> java로 만들어진 모든 클래스들의 최상위 클래스의 역할을 하는 클래스
	따라서 java로 만들어진 모든 class는 Object가 제공하는
	모든 기능 (함수, 변수)을 자동적으로 사용할 수 있게 된다.
	
	public class Abc{}	==> Object(+a)
	
	Object o=new Abc();	==> 다형성

	+ the reason there is Object class
		계층추적을 원활하게 하기 위한 조치
		즉, each class's 족보를 정확하게 따질 수 있도록 하기 위해
		
	+ all class maked by java must have Super class.
		우리가 지금까지 만든 클래스들도 상위 클래스를 갖고 있다.
		if 강제로 상위 클래스를 지정하지 않으면
		암묵적으로 Object라는 클래스를 상속받아 만들어진다.
		
	* instance of 연산자
	==> 특정 클래스를 new 시키면 주소가 만들어진다.
		이 주소가 어떤 클래스 소속의 주소인지를 알아내는 연산자.
		결과값은 true/false로 만들어진다.
		
		형식)
			address insatceof classname
		
		meaning)
			주소가 가리키는 내용이
			지정한 클래스 소속인지 물어본다.
			
		+ 소속이라는 개념은 is a 관계를 따지는 것이다.
			상속관계를 따지는 개념이 소속.
			
---------------------------------------------------------------------
Package and import

	What is Package?
	==> java program(source code)가 들어있는 폴더를
		java에서 부르는 용어
		
		java is opened source.
		All people can provide the program they made
		and all people can use this
		그러다보니 문제점이 발생했는데
			클래스 이름이 충돌할 수 있다.
		Package can resolve this prolem.
		
		즉, 소스를 만드는 사람이 그 프로그램이 포함되는 폴더이름까지 정해서
		프로그램을 만들도록 하는 것.
		
		결론적으로
		if make program by using java,
		이 프로그램이 어떤 폴더에 저장되는지 알려주도록 해 놓았다.
		
		명령
			package name;
			
		+ 패키지 이름을 만드는 권장사항
			자신이 사용하는 도메인을 거꾸로 쓴 후
			그다음에 다시 폴더 이름을 붙여 만들어준다.
			
			ex.
				githrd.com	==> com.githrd.t0310
				
	What is import?
	==> 자신이 사용할 클래스가
		어느 폴더(패키지)에 있는 클래스를 사용할 것인지 밝히기 위한 명령
		
		형식 1)
			import package.class;
			==> 지정한 폴더의 지정한 클래스를 사용할 예정임을 밝히는 것.
				후술할 형식2보다 우선시된다.
			
		형식 2)
			import package.*;
			==> 지정된 패키지의 모든 클래스를 사용할 예정임을 밝히는 것.
			
		<Warning!>
			t1--s1--...
			       ㄴ  s2--Test1.java
			   |    ㄴ Test2.java
			   |    ㄴ Test3.java
			       ㄴ Test01.java
			       ㄴ Test02.java

		일 경우,
			import t1.*; ==> Test01,Test02만 사용할 수 있다.
			
			만약 Test1을 사용하려면
			import t1.s2.*;라고 별도로 import해줘야 한다.
			
		따라서, *기호를 사용한 import명령은
		Sub package내의 클래스를 포함하지 않는다.
		직속 클래스만이 포함된다.
		
	+ Should we import all package?
	  import하지 않아도 명시적으로 사용할 수 있는 package가 있다.
	  ==> java.lang package!
	  	JVM이 기본적으로 찾아보는 패키지임.
	  	
---------------------------------------------------------------------
static import
==> in principle, static member can be used...

	class.member
	
	Math.PI
	Math.random()
	이 때, static member 앞에 사용하는 class 이름도 생략할 수 있다.
	==> when we use static member,
		클래스 이름을 생략할 수 있게 하는 방법은
		static import	이다!
		
	형식)
		import static package.class.*;
		
		random()	==> Math.random 사용 가능.
		
---------------------------------------------------------------------
final

	1. final 변수
	   ==> 변수의 값을 수정할 수 없다.
	   		선언과 동시에 초기화를 하는것이 일반적.
	   		
	2. final Method
	   ==> this method can not Overrided.
	   
	3. final class
		==> this class can not be super class.

---------------------------------------------------------------------
상위 클래스 타입 변수로 하위 클래스 인스턴스를 기억하는 경우,
변수는 reference 쪽을 따르고 함수는 instance 쪽을 따른다.
(영어 원어 뜻으로 이해하면 편함!)

단, reference쪽에 실행하려는 함수가 존재하여야 한다.

(Heap, static)메모리에 올린다는 개념은 클래스를 벗어나도 사용할 수 있게끔 한다는 것에 의의가 있나요?