# day18

Thread
  +	java가 프로그램을 실행시키는 법
	1. Processor를 이용
	==> 운영체제에 의해 자신이 사용할 메모리를 할당받고
		레지스터리에 등록한 후 실행.
		
		단점
			각각의 Process program은
			원칙적으로 자신의 데이터를 다른 Process program에게
			주지 못한다. (메모리끼리 호환X)
			
		우리는 지금까지 이 방식으로 모든 프로그램을 실행했다.
		(즉, main 함수로부터 시작하는 프로그램은 이 방식을 취함)
		
		
	2. Tread를 이용
	==> 독립적인 메모리를 할당받지 않고 실행하는 프로그램.
		대신 process 프로그램이 사용하는 메모리를 공유한다.
		
		  +	Tread는 독립적인 실행이 불가능.
		  	반드시 다른 프로세스가 실행 된 후 실행돼야 함.
		  	
		장점
			Tread 프로그램은 메모리를 같이 사용하므로
			같은 메모리를 사용하는 프로그램 끼리는
			데이터 교환이 가능!

--------------------------------------------------------------------
~용어 정리~
	1. 시분할 시스템
	==> CPU는 프로그램 한 개씩만 실행 가능.
		하지만 여러 프로그램을 동시에 실행하고 싶을때가 있쥬.
		
		동시에 실행할 프로그램이 여러개일 경우
		각각의 프로그램마다 CPU가 실행 시간을 정한 후
		그 시간만큼만 각 프로그램을 실행한다.
		
	2. 우선순위(Priority)
	==> CPU는 시분할 시스템에 의해,
		특정 프로그램을 배분한 시간만큼 실행한다.
		
		실행이 끝나고 그 다음으로 실행할 프로그램을 정하는데,
		그 기준이 우선순위이다.
		
--------------------------------------------------------------------
java에서 Thread 프로그램을 만드는 방법

	1. Thread 클래스의 상속
	
		1) Thread 클래스의 sub class를 생성
		2) 그 클래스 안에 꼭!! run()함수를 Override 한다.
			(이 함수가 process 방식인 main() 함수에 해당하는 것으로
			Thread 프로그램의 시작함수가 됨)
		3) run() 함수로부터 출발해,
			그 프로그램이 하고자 하는일을 코딩한다.
	
			
	2. Runnable 인터페이스의 구현
	
		1) Runnable 인터페이스를 구현한 클래스 제작.
		2) 그 클래스 안에 run()함수 Override. (작동방식은 1.과 동일)
		3) run()함수로부터 출발해,
			그 프로그램이 하고자 하는일을 코딩한다.
			
			
	  +	Thread와 Runnable의 차이?
	  	상속은 오직 한개만 허용하므로
	  	또 다른 클래스를 상속하고자 한다면 Thread가 불리.
	  	그래서 또 다른 방법인 Runnable을 제공하고 있다.
	
	  +	Runnable의 상태
		==> CPU가 시분할 시스템이 의해 프로그램을 선택할 때,
			선택가능한 프로그램이 모여있는 상태
			
			
	*****	New Born 상태 -> Runnable 상태로 전위시키는 명령
				start();

			+ run() 함수와의 오인
			  run 또한 실행 함수인데, 이건 Thread 동작이 아니다.
			  processer의 한 함수만 호출된다. (병행처리X)


			Run 상태
			==> CPU가 특정 프로그램을 실제로 실행하는 상태를 말한다.
				Run 상태는 오직 한개의 프로그램만 들어갈 수 있다.
				그리고 Runnable -> Run의 전위는 오직 운영체제 몫임.
				(개발자가 손댈 수 없다!)
				
				+ 사실...
				  1. 운영체제 몫 : 시분할 시스템
				  2. 개발자가 선택할 수도 있음...

	그래서 Thread 왜 필요한데?
		1. 독립적으로 실행이 필요한 경우
		==> 서버 프로그램에선 각 클라이언트, 통신하는 프로그램이
			독립적으로 실행돼야 한다.
			
		2. 백그라운드 작업이 필요한 경우
		==> 그래픽 처리를 하거나
			그림을 내부적으로 완성 후, 메인은 완성된 그림만 쓸 경우
			

	Thread 동작시키기~
		1. Thread 상속의 경우
			1) new 시킨다 -> new Born
			2) start()	-> Runnable 상태로 전위시킴
			
		2. Runnable 구현의 경우 (new Born 의 방식이 다름!)
			1) new 시킨다
			2) Thread 클래스를 new 시키면서 1)의 결과를 넣어준다.
			   -> 이때 new Born
			3) 2)의 결과를 이용, start 시킨다.	-> Runnable 상태로 전위

		  +	하나의 Thread 프로그램은 여러번 실행할 수 있다.
		  	그러면 이들은 각각 독립적으로 실행된다.
		  	즉, 하나의 Thread 처럼 여러개 프로그램이 실행된다.


	Thread의 이름
	
		String name=Thread.currentThread().getName();

	
	1. Run->Runnable 상태로 전위 (실행-> 실행 대기)
		
			yield();

	  +	Block 상태란?
	  	실행을 잠시 중단하는 상태.
	  	이 상태에 있는 프로그램은 절대 실행되지 않음.
	  	(Runnable에 있어야 실행 가능)
	  	
		Block 상태를 해제하려면
		Runnable 상태로 전위되는것 외엔 방법이 없다!


	2. Run->Block 상태로 전위
	
			sleep(밀리세컨드)

		이 명령은, 지정한 시간동안만 Block 상태로 만들어준다.
		지정 시간이 끝나면 Runnable로 복귀됨.

--------------------------------------------------------------------
Thread가 있는 프로그램의 종료
==> 일반적으로, Thread가 존재하지 않는 process 프로그램은
	main()이 종료되면 프로그램도 종료된다.
	하지만! Thread가 존재하는 프로그램은
		1. main()도 종료
		2. Thread도 종료		두 가지 모두 충족해야 종료됨!
		
		
	1. Thread 강제종료 방법
			stop()		얘는 사용 금지 명령임.

		  +	java에선 이 함수를 사용 금지 함수로 만듦.
		  	대신 Thread가 스스로 종료하는 방향으로 프로그램을 제작해
		  	프로그램이 종료될 수 있도록 처리한다.
		  	즉, run()이 자연스럽게 종료되게 하는 것!
		  	
		  +	프로그램의 종료
		  	main()이 종료되면 process 프로그램이 종료되듯
		  	run()이 종료되면 Thread 프로그램이 종료된다.

		정리
			run() 함수는 제어변수를 이용해 반복하도록 처리한다.
				while(isStart){
				}
			그리고 Thread가 종료될 필요가 있으면,
			이 제어변수를 조작함으로써 run()이 종료되도록 유도함.
				isStart=false;


		  +	한번 Death된 Thread는 다시 실행할 수 없다.
			재실행을 원하면, 다시 new Born부터 다시 시작해야 함!

	일시중지
	
		일시중지	suspend()
		재실행		resume()

		근데 얘네들도 사용 금지 명령.
		후술할 동기화 기법으로 대체하게 해 놓았다!

--------------------------------------------------------------------
동기화 처리
==> Thread의 장점은 메모리를 공유한다는 것!
	근데 이건 매우 어려운 내용이다.
	왜냐면 Thread가 어디까지 실행할지 몰라서.
	
	동기화란?
	==> 특정 Thread가 어디까지 실행할지 묶어두는 기능
	
	
	종류
		1. 변수의 동기화
		==> Thread가 특정 기능을 마칠 때까지
			특정 변수를 타 Thread가 쓰지 못하게 방지하는 것.
			
			형식
				synchronized(변수){}
				
			의미
				하나의 변수가 Thread{}를 모두 실행하는 도중엔
				다른 Thread는 이 변수를 사용하지 못하게 한다.
		
		2. Method의 동기화
		==> Thread가 특정 Method를 실행하는 도중엔
			특정 Method를 타 Thread가 쓰지 못하게 하는 것.
			
			형식
				synchronized 반환값 함수이름 (매개변수){}
				
			의미
				하나의 Thread가 이 함수를 실행하는 도중엔
				다른 Thread는 이 Method를 사용하지 못하게 한다.

--------------------------------------------------------------------
동기화 이용 방법
==> 보통 2개 이상의 Thread를 만들 때엔
	대부분 다른 일을 동시에 하기 위해서 만든다. (같은 작업을 할 수도 있겠지만..)
	이 때, 공유 데이터가 존재하면 문제가 생길 수 있다.
	
	하지만 전술한 동기화의 문제점은
		한쪽 Thread가 하나의 작업을 완료할 때까지
		다른 Thread는 대기해야 한다!
		이건 엄밀히 말하면, Thread를 쓰는 효과가 없다는거다!
		
	
  *	서로가 병행처리를 하면서, 공유데이터가 손상되지 않게 하는법!
	규칙!
		1. 특정 Thread가 작업을 해선 안될 시점이 되면
			스스로가 Block 상태로 전위되게 한다.
				wait()
				
		2. 다른 Thread입장에선, 타 Thread가 실행돼도 좋을 시점에 깨워준다.
			==Runnable로 복귀시킨다.
				notify()
				
*****	3. wait(), notify()는 반드시 동기화 함수 안에서만 사용해야 한다!

	
	자기 자신을 Block 상태로 만드는 방법
		1. sleep()
		==> 지정한 시간 동안(ms, ns) 스스로를 Block 상태로 만든다.
		
		2. join()
		==> 다른 Thread가 종료되기 전까지 스스로를 Blcok 상태로 만든다.



