# day15

Random class
==> 난수를 발생시키는 클래스.
	우리가 지금까지 쓴 Math.random()보단 
	좀 더 다양한 형태의 난수를 발생시킬 수 있다.
	
	+ seed
	==> 컴퓨터에 난수 발생은 그 순간 실제로 난수를 만들어 주는게 아닌,
		컴퓨터 내부에 이미 존재하는 난수 테이블에서
		순서대로 꺼내주는 것인데, 이 위치를 말하는 용어가 seed다.

-------------------------------------------------------------------
BigDecimal
==> 정수를 표현할 수 없는 숫자를 사용하기 위한 클래스.

	주로 데이터베이스와 연동할 때.
	
	데이터베이스의 숫자타입은
		오라클의 경우 NUMBER(숫자)는 최대 32자리까지 가능.
	이런 형태의 데이터는 java에선 처리 불가하므로
	이런 유형의 데이터를 처리하기 위해 만들어진 클래스이다.
	
	ex.
		BigDecimal big=("200012092000060620000323");
		요렇게 문자열 형태로 입력한다.
		
-------------------------------------------------------------------
정규(표현)식 검사
==> 주어진 문자열이 특정한 규칙에 맞도록 만들어져 있는지 확인하는 기능

	ex.
		주민번호가 6자리-7자리 로 구성되어 있는지
		ID가 순수하게 숫자와 문자로만 구성되어 있는지
		PW가 최소 몇글자 이상으로 만들어져 있는지		등
		
	사용하는 클래스
		java.util.regex.Pattern;
		==> 정규식 검사에 사용할 '정규식 문법을 지정'할 클래스
		
		java.util.regex.Matcher;
		==> 정규식 검사를 실제로 '실행 할' 클래스
		
	+ 정규 표현식 문법
	
		1. c[a-z]*
		   ==> 문자를 기록하면 반드시 그 위치에 기록한 문자가 와야 함.
		   	   [] 안에 기록하면, 그 중 하나가 와야 한다는 것.
		   	   * 은 바로 앞에서 지정한 글자가 0개 이상 올 수 있다는 것
		   	   
			==> 그래서 무슨의민데?
				c로 시작하고 / 뒤엔 알파벳 소문자가 0개 이상 오면 됨.
				
		2. c[a-z]
			==> c로 시작하고 / 뒤엔 알파벳 소문자가 한글자 와야 함.
			
		3. c[a-zA-Z]
		==> c로 시작하고 / 뒤엔 알파벳 아무거나 한글자 오면 됨.
		
		4. c[a-zA-Z0-9]
		==> c로 시작하고 / 뒤엔 알파벳 또는 숫자가 한글자 오면 됨.
		
		5. .*
		==> .은 모든 문자(언어 안가림)를 의미함!
		==> 아무거나 0개이상 쓰세여. 라는 뜻~
		
		6. C.
		==> C로 시작하고 / 뒤엔 암거나 한글자 쓰세여.
		
		7. C.*
		==> C로 시작하고 / 뒤엔 암거나 0개 이상 쓰셔유.
		
		8. c\.
		==> \.는 반드시 그 위치에 .이 와야함.
		==> c.여야 함!
		
		9. c\d
		==> \d는 숫자임.
		==> c로 시작하고 / 숫자를 하나 쓰라는거긔.
			== c[0-9]
			
		10. c.*t
		==> c로 시작하고 / 마지막글자는 t가 와야함!
			(중간에 어떤 글자라도 0개 이상 올 수 있다!)
			
		11. [b|c].*
		==> b또는 c로 시작하고 / 뒤에 암거나 0개 이상 오면 됨.
			== [bc] == [b-c]	(이어져 있응께)
			
		12. [^b|c]
		==> ^는 not이여. b또는 c가 아님 되는겨. 고런 문자 하나.
		
		13. .*a.*
		==> a가 포함된 아무 문자열이나 쓰셔.
		
		14. .*a.+
		==> +는 한글자 이상이란 뜻.
		==> a가 포함됐고, a이후 한글자라도 있는 문자열을 쓰시오.
		
		15. [b|c].{2}
		==> {숫자}			: 글자수를 의미
			{숫자,}			: 숫자 이상의 개수를 의미
			{숫자a, 숫자a}	: 숫자 a개 이상 b개 이하의 의미
		==> b또는 c로 시작하고 / 그 이후에 어떤 문자라도 2글자가 와야 함.
		
		16. .{2, 3}
		==> 어떤문자라도 2~3글자가 와야함.
		
	ex. 핸드폰 번호 표현식
	
		01\d-[0-9]{4}-[0-9]{4}
		
		전화번호
			0\d{2,3}-[0-9]{4}-[0-9]{4}
			
-------------------------------------------------------------------
Collection
==> 많은 양의 데이터를 손쉽게 보관할 수 있는 클래스들의 집합

	배열을 이용해도 되지만..
	단점!
		1. 크기를 변경할 수 없다.
		2. 위치를 알아야만 입출력이 가능하다.
		
	종류
		1. List 계열
			특징
				1. 입출력 순서를 보장함. (처리속도 느림)
				2. 중복 데이터도 다시 저장할 수 있음
		2. Set 계열
			특징
				1. 입력 순서를 보장하지 못한다.
					(나름의 규칙에 의해 데이터를 정렬하고 보관.
					처리속도 빠름)
				2. 중복 데이터 X
				==> 중복 데이터가 있을 경우 덮어쓰기 한다.
		3. Map 계열
			특징
				1. 데이터를 그 데이터를 구분하는 키값과 한 쌍을 만들어 저장.
				2. 입력 순서 보장X
				3. 같은 키 값으로 데이터가 입력되면 덮어쓰기 한다.
				==> 데이터는 중복되어도 상관X.
				
		+ List 계열과 Set 계열은 같은 super class를 갖는다.
		  Map 계열은 다름~
		  ==> List와 Set은 다형성 처리가 가능! (서로 변환이 가능)
		  	  Map은 독립적으로 변환할 수 없음.
		  	  
-------------------------------------------------------------------
Collection-List 계열
무엇이 있느뇨?

	1. Vector
	==> 내부적으로는 배열 형태를 만들어 데이터를 보관하는 Collection의 일종.
		장점 : 입력/검색속도가 빠름.
		단점 : 중간에 데이터를 삽입/삭제하는 속도가 느림.
		결론 : 데이터의 변화가 거의 없는 프로그램에서 유리.
		
		생성방법
			1. Vector()
			==> 배열의 크기를 10으로 정한 상태로 10터를 만들어 줌.
				이 때 데이터가 많으면, 자동으로 크기가 변경된다. (*2 만큼)
				
			2. Vector(Collection c)
			==> 다른 컬렉션의 데이터를 복사하여 Vector를 만든다.
			
			3. Vector(int initialCapacity)
			==> 사용자가 직접 배열의 크기를 정하면서 벡터를 만든다.
			
			4. Vector(int initialCapacity, int capacityIncrement)
			==> 3번+변형된 1번.
				데이터 양이 증가할 때, 추가할 배열의 크기를 지정 가능.
				
		+ Collection은 데이터 양에 무관하게, 항상 데이터를 입력받을 수 있다!
		  이 때, 입력받을 공간을 확보해야 하는디
		  규칙
		  	현재공간*2		가 된다 이거여.
		  	
		주요함수
			1. 데이터 입력 함수
				add(Object obj)
				add(int index, Object element)
				addAll(Collection c)	==> 다른 컬렉션 데이터 이전 가능
				addElement(Object obj)
				insertElementAt(Object obj, int index)
				
			2. 데이터 수정 함수
				set(int index, Object element)
				setElementAt(Object obj, int index)
				
			3. 데이터 출력 함수
				get(int index)
				elementAt(int index)
				firstElement()
				lastElement()
				elements()
				
			+ E, V, K라고 표한 것은 Object를 의미하는 제너릭스 용어다.
				E : Element
				V : Vector
				K : Key (값)
				
				
				
	2. ArrayList
	==> Vector의 신version!
		역시 배열 형태로 관리하기에, Vector의 특징 그대로 갖는다.
		But! Thread에서 동기화 처리를 자동으로 해주기에
		최근 Vector보다 ArrayList를 선호하는 경향이 보인다.
		
		사용방법 또한 Vector와 유사하다.
		
		+ List계열의 주소(변수)를 출력하면
		  데이터가 나온 것 처럼 보이지만,
		  override 된toString() 함수이다.
		  따라서, 데이터를 사용하는 개념은 아니다!
		  
	3. LinkedList
	==> 내부적으로 이중연결 리스트 방식으로
		데이터를 보관하는 방식의 컬렉션의 일종.
		
		장점 : 데이터를 중간에 추가/삭제 할 때 속도가 빠름.
		단점 : 데이터를 누적시키는 것이 느리다.
		결론 : 데이터 변화가 심한경우 유리.
		
	+ Iterator
	==> Collection은 많은 클래스의 집합이며, 그 형태도 다르다.
		But. 얘네는 서로 혼용해 사용 가능하다.
		근데 그 안에 데이터를 꺼내는 방식은 약간씩 달라용.
		(꺼내는 소스를 다르게 만들어야 된다는 거쥬.)
		
		그래서! 데이터를 꺼내기 위해서만 사용하는 클래스를 만들엇삼.
		그게 바로 Iterator 요녀셕이다 이거지라.
		List계열orSet계열->Iterator로 변환시키면
		한 가지 방식으로 데이터를 꺼낼 수 있다!
		
		특징
			StringTokenizer처럼 순차적으로 꺼내며, 한번 꺼내면 사라짐!
			
	+ Collection class
	==> 이름은 Collection인 클래스인디, Collection의 기능은 없다!
		Collection을 이용할 때 필요한 부가적인 기능들을 제공하는
		utility 적인 클래스이다.
		
		주의 : 매개변수에서 List를 달라 카믄 List 계열을 줌 된다.
				Set 달라 카믄 Set주믄 되는기고.
				Collection 달라카믄 Collection 주믄되는거 아이가?
				=> 아이다. List나 Set형태로 줘야칸다.
				Map달라카믄 그대로 걍 Map 줘뻐리면 된다.
	
	+ 일반적인 sort(정렬)은 오름차순이다.
	  정렬 방식을 변경하고자 한다면
	  sort(List list, Comparator c)	를 써야 함!
	  
-------------------------------------------------------------------
Set계열
==> 입력한 순서대로 보관하고 있을 보장이 없다.
	(자기 나름의 규칙을 갖고 내부적으로 정렬해 보관함!)
	중복된 데이터는 한번만 저장함.
	
	1. HashSet
	==> HashCode를 이용한 정렬로 보관하는 컬렉션.
		따라서 우리가 생각하는 정렬이 이루어지지 않는다.
		
		+ Set계열의 컬렉션은 꺼내는 기능의 함수가 존재하지 않음.
		  ==> 개발자가 저장된 장소를 모르기 때문에!
		  		이 때 Iterator를 쓴답니다.
		  		List계열로 변환해, index를 사용해 꺼내도 OK.

	2. TreeSet
	==> 내부적의 Tree Sort라는 알고리즘대로 데이터를 보관하는 컬렉션.
		특징
			우리가 생각하는 정렬방식을 사용함.
			
		생성방법
			TreeSet(Comparator comparator)
			==> 정렬 방식을 변경해서 TreeSet을 만든다.
			
			TreeSet()
			==>	순서를 정할 수 있는 데이터만 가능, 오름차순 정렬
				-> 객체타입 불가능
				
			TreeSet(SortedSet<E> s)
			==> TreeSet을 이용해 다시 TreeSet을 만든다.
			
		+ 참고함수
			subSet()
			==> 하나의 Set에 담긴 내용 중에서, 특정 부분만 골라
				새로운 Set을 만드는 함수
				
			headSet(E toElement)
			==> 처음~지정한 부분 을 골라 새로운 Set을 만듦
			
			tailSet(E fromElement)
			==> 지정한 부분~끝 을 골라 새로운 Set을 만듦