# day14

오버라이드 규칙~
	1. 함수의 원형을 유지한다.
	2. 접근지정자는 같거나 넓은 방향으로.
	3. 예외처리는 같거나 좁은 방향.
		-> 예외를 전이하는 함수일 경우,
			throws하는 예외는 개수가 같거나 줄어들 수 있다.
		-> super class에서 던지지 않은 예외를 던지면 X.
		
		ex.
			void add(int a, int b) throws InvalidNumberException,
				NotANumberException {}
			얘를 오버라이드 해서
			
			@Override
			void add(int a, int b) throws InvalidNumberException,
				NotANumberException {}	==> 가능쓰
				
			@Override
			void add(int a, int b) throws InvalidNumberException {}
			==> 가능쓰! (줄어든건 ㄱㅊ)
			
			@Override
			void add(int a, int b) throws Exception {}
			==> NG! (예외의 범위가 더 넓어졌삼~~!)
			
			@Override
			void add(int a, int b) throws NumberException {}
			==> (NumberException은 위의 예외와 형제 예외로 침)
				NG! 상위 클래스의 함수에서 던지지 않은 예외라 안됨!
				
-------------------------------------------------------------------
Object class
==> 자바로 만든 클래스의 최상위 클래스 역할을 하는 클래스.
	자바에서 상속관계를 명확하게 하기 위한 역할을 주로 한다.

	1. equals()
	==> 비교함수.
		Object 클래스가 갖는 이 함수는
		내용이 아닌 주소를 비교한다.

	+ 우리가 만드는 클래스를 사용하는 법.
		1. 객체를 만들어야 함 (Heap영역에 내용 올려놓기)
		2. 변수(주소)를 이용하여 내부의 맴버들을 사용한다.

	+ 우리가 String class의 equals()를 내용 비교 함수로 알고 있다!
		요것은. String class가 Object class에서 Override할 때
		내용 비교 함수로 바꿨기 때문이다~~!

	+ 우리가 만드는 클래스도 내용 비교를 원한다면
		이 함수를 override하면 될것임~



	2. toString()
	==> 자바는 주소를 내부적으로 사용하고 있다!
		주소를 개발자에게 노출시키진 않는다.

		대신, 주소(변수가 기억하고 있는)를 출력하면
			"클래스이름@해쉬코드값"
		의 형태로 출력하게 된다.
		
		+ 해쉬코드값?
		==> 자바는 주소를 내부적으로 해쉬테이블을 이용하여 관리함.
			해쉬코드값은 해쉬테이블의 코드값임. (엑셀 표 처럼)

			문제는, 주소를 출력하려고 하면 내용이 출력되는게 아니라
			해쉬코드 형태의 코드값이 출력된다는 거여.
			
			만약 우리가 만든 클래스에서 주소(변수)를 출력할 때
			해쉬코드값이 아닌, 데이터를 출력하게 하려면
			toString()함수를 Override하여
			원하는 형태의 문자열을 반환해주도록 만들어주면 되는것이여.



	3. clone()
	==> 자기 자신을 깊은 복사 해주는 함수
	
		이 함수는 protected 함수이다.
		상속받은 클래스or같은 패키지 안에 있는 클래스에서만 사용 가능.
		
	4. hashCode()
	==> 해쉬테이블에 주소를 관리하는 코드값을 알려주는 함수.
		




